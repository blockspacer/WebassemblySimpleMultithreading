<html>
	<script>
		(async ()=>{			
			// settings 				
			const path = 'test.wasm';
			const memory_init_pages = 4;
			const page_size = 0x10000;
			const heap_start = page_size * memory_init_pages;
			
			const memory = new WebAssembly.Memory( { initial: memory_init_pages,shared: true, maximum:20} );
			const table = new WebAssembly.Table({ initial: 1337, element: 'anyfunc' });
			
			// load wasm
			const response    = await fetch( path );
			const raw_buffer  = await response.arrayBuffer();
			const wasm_module = await WebAssembly.compile(raw_buffer)
			
			const imports = { };
			imports.env = { };
			imports.env.memoryBase = 0;
			imports.env.memory = memory;
			
			imports.env.tableBase = 0;
			imports.env.__indirect_function_table = table;
			
			imports.env.startThread = ( wasm_exported_function ) => {
				console.log("Main: starting Thread on function: %d" , wasm_exported_function )
				
				let worker = new Worker("/worker.js");			
				worker.onmessage = function(e) {};

				// sending the thread data to the worker thread 
				let thread_info = {
					command : "thread_start",
					thread_entry_ptr : wasm_exported_function,
					memory : memory,
					module : wasm_module,
				}

				worker.postMessage(thread_info);				
			}

			imports.env.someFunc = ( ) => console.log("Main: imports.env.someFunc called" )
			
			// Instantiate the module
			const instance = await new WebAssembly.Instance(wasm_module, imports );

			console.log( "WebAssembly::Instance" );
			console.log( "WebAssembly::Memory Size: %d Bytes" , memory.buffer.byteLength );
			console.log( "WebAssembly::Table Size: %d Entries" , table.length );
			console.log( "WebAssembly::__heap_base is @0x%s" , (instance.exports.__heap_base).value.toString(16));
			console.log( "WebAssembly::__data_end  is @0x%s" , (instance.exports.__data_end).value.toString(16));
			
			console.log("Main: main called");
			const adr = instance.exports.main();
			setInterval( () =>console.log(instance.exports.lol()), 100 )
			
		})();
	
	
	</script>
</html>
 